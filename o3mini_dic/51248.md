```json
{
  "word": "destructor",
  "phonetics": "/dɪˈstrʌk.tər/",
  "part_of_speech": "n.",
  "translation": "析构函数",
  "definition": "A special member function in object-oriented programming that is automatically invoked when an object is destroyed or goes out of scope, primarily used to release resources and perform cleanup tasks.",
  "example": "In C++, the destructor of a class is automatically called to free up memory when an object is no longer needed.",
  "synonyms": ["finalizer"],
  "antonyms": ["constructor"],
  "usage": {
    "simple_present": [
      { "question": "The destructor frees allocated memory.", "translation": "析构函数释放分配的内存。" },
      { "question": "Every object has a destructor to clean up resources.", "translation": "每个对象都有一个析构函数来清理资源。" }
    ],
    "present_continuous": [
      { "question": "The destructor is running as the object goes out of scope.", "translation": "当对象超出作用域时，析构函数正在执行。" },
      { "question": "Our program is calling the destructor automatically.", "translation": "我们的程序正在自动调用析构函数。" }
    ],
    "present_perfect": [
      { "question": "The class has provided a virtual destructor to ensure proper cleanup.", "translation": "该类提供了一个虚析构函数以确保正确的清理。" },
      { "question": "Developers have implemented custom destructors in many modules.", "translation": "开发人员在许多模块中实现了自定义析构函数。" }
    ],
    "present_perfect_continuous": [
      { "question": "The destructor has been handling resource cleanup effectively in the new system.", "translation": "在新系统中，析构函数一直在有效地处理资源清理工作。" },
      { "question": "Engineers have been refining the destructor's performance during debugging.", "translation": "工程师们在调试过程中一直在改进析构函数的性能。" }
    ],
    "simple_past": [
      { "question": "The destructor released the resource correctly when the object was deleted.", "translation": "当对象被删除时，析构函数正确地释放了资源。" },
      { "question": "Yesterday, the program called the destructor as soon as the object went out of scope.", "translation": "昨天，当对象超出作用域时，程序立即调用了析构函数。" }
    ],
    "past_continuous": [
      { "question": "The destructor was running while the garbage collector operated.", "translation": "当垃圾回收器运行时，析构函数正在执行。" },
      { "question": "The system was invoking the destructor as the application was closing.", "translation": "应用程序关闭时，系统正在调用析构函数。" }
    ],
    "past_perfect": [
      { "question": "Before the update, the destructor had caused a memory leak in some cases.", "translation": "在更新之前，析构函数在某些情况下曾导致内存泄漏。" },
      { "question": "The system had invoked the destructor before shutting down completely.", "translation": "系统在完全关闭之前调用了析构函数。" }
    ],
    "past_perfect_continuous": [
      { "question": "The program had been using a faulty destructor before the bug was fixed.", "translation": "在修复该bug之前，程序一直在使用有缺陷的析构函数。" },
      { "question": "Developers had been testing the destructor's behavior for hours before deployment.", "translation": "在部署之前，开发人员已经测试了几个小时析构函数的行为。" }
    ],
    "simple_future": [
      { "question": "The destructor will be called automatically when the object is deleted.", "translation": "当对象被删除时，析构函数将被自动调用。" },
      { "question": "In the new release, the destructor will handle additional logging tasks.", "translation": "在新版本中，析构函数将负责额外的日志记录任务。" }
    ],
    "future_continuous": [
      { "question": "While the program runs, the destructor will be managing resource cleanup.", "translation": "在程序运行时，析构函数将一直管理资源清理工作。" },
      { "question": "During the shutdown phase, the destructor will be deallocating memory.", "translation": "在关闭阶段，析构函数将一直在释放内存。" }
    ],
    "future_perfect": [
      { "question": "By the next update, the improved destructor will have optimized resource management.", "translation": "到下一次更新时，改进后的析构函数将已经优化了资源管理。" },
      { "question": "By then, the new destructor will have resolved the previous memory issues.", "translation": "到那时，新析构函数将已经解决了之前的内存问题。" }
    ],
    "future_perfect_continuous": [
      { "question": "By the end of the project, the destructor will have been handling cleanup for all objects consistently.", "translation": "到项目结束时，析构函数将一直在一致地清理所有对象。" },
      { "question": "By that time, the destructor will have been managing resources across multiple modules for a long period.", "translation": "到那时，析构函数将已经在多个模块中长时间管理资源。" }
    ],
    "subjunctive_mood": [
      { "example": "If the destructor were implemented correctly, no resource leaks would occur.", "translation": "如果析构函数实现正确，就不会发生资源泄漏。" },
      { "example": "If a proper destructor were provided, cleanup would be automatic.", "translation": "如果提供了合适的析构函数，清理工作就会自动进行。" }
    ],
    "passive_voice": [
      { "example": "The destructor was called automatically by the runtime system.", "translation": "析构函数被运行时系统自动调用。" },
      { "example": "Resources are released by the destructor before the program terminates.", "translation": "在程序终止前，资源由析构函数释放。" }
    ],
    "interrogative_sentences": [
      { "question": "When is the destructor invoked in the lifecycle of an object?", "translation": "析构函数在对象生命周期中什么时候被调用？" },
      { "question": "How does the destructor ensure that resources are properly freed?", "translation": "析构函数如何确保资源被正确释放？" }
    ],
    "negative_sentences": [
      { "example": "The destructor does not get called if the object is not properly deleted.", "translation": "如果对象没有被正确删除，析构函数不会被调用。" },
      { "example": "It didn't handle all cleanup tasks, so the destructor failed to free some resources.", "translation": "它没有处理所有清理任务，因此析构函数未能释放部分资源。" }
    ]
  },
  "phrases": {
    "examples": [
      { "phrase": "default destructor", "translation": "默认析构函数" },
      { "phrase": "virtual destructor", "translation": "虚析构函数" }
    ],
    "idioms": [
      { "phrase": "RAII (Resource Acquisition Is Initialization)", "translation": "资源获取即初始化" },
      { "phrase": "object lifetime", "translation": "对象生命周期" }
    ]
  }
}
``` 