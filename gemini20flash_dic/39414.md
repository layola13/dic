```json
{
  "word": "connascency",
  "phonetics": "/kəˈnæsənsi/",
  "part_of_speech": "noun",
  "translation": "耦合性, 关联性 (在软件工程中)",
  "definition": "In software engineering, connascency refers to the degree to which two or more modules in a system rely on each other. It's a generalization of the concept of coupling, describing the different ways in which modules can be interconnected and dependent on each other. High connascency implies that changes in one module are more likely to necessitate changes in another, making the system harder to maintain and evolve.",
  "example": "High connascency between classes can lead to a brittle system, where seemingly small changes have cascading effects.",
  "synonyms": ["coupling", "dependency", "interdependence", "cohesion (opposite)"],
  "antonyms": ["decoupling", "independence"],
  "usage": {
    "general": [
      {
        "example": "Connascency is a crucial consideration when designing modular and maintainable software.",
        "translation": "在设计模块化和可维护的软件时，关联性是一个重要的考虑因素。"
      },
      {
        "example": "Reducing connascency improves the resilience and flexibility of the codebase.",
        "translation": "降低关联性可以提高代码库的弹性和灵活性。"
      }
    ],
    "types_of_connascency": [
      {
        "type": "Connascency of Name (CoN)",
        "description": "Modules must agree on the name of an entity.",
        "example": "Two modules both reference the same database table name.",
        "translation": "模块必须对实体的名称达成一致。例如：两个模块都引用了相同的数据库表名。"
      },
      {
        "type": "Connascency of Type (CoT)",
        "description": "Modules must agree on the type of an entity.",
        "example": "One module expects a string while the other provides an integer.",
        "translation": "模块必须对实体的类型达成一致。例如：一个模块期望一个字符串，而另一个模块提供一个整数。"
      },
      {
        "type": "Connascency of Value (CoV)",
        "description": "Modules must agree on a specific value.",
        "example": "Two modules use the same constant for a discount rate.",
        "translation": "模块必须对特定的值达成一致。例如：两个模块使用相同的常量作为折扣率。"
      },
      {
        "type": "Connascency of Position (CoP)",
        "description": "Modules must agree on the order of data.",
        "example": "A function expects arguments in a certain order, but they are passed in a different order.",
        "translation": "模块必须对数据的顺序达成一致。例如：一个函数期望按特定顺序排列的参数，但它们以不同的顺序传递。"
      },
      {
        "type": "Connascency of Algorithm (CoA)",
        "description": "Modules must agree on a specific algorithm.",
        "example": "Two modules perform the same calculation, but one has a bug.",
        "translation": "模块必须对特定的算法达成一致。例如：两个模块执行相同的计算，但其中一个有错误。"
      },
      {
        "type": "Connascency of Identity (CoI)",
        "description": "Modules must agree on the identity of an entity.",
        "example": "Two modules operate on the same object instance.",
        "translation": "模块必须对实体的标识达成一致。例如：两个模块操作同一个对象实例。"
      },
      {
        "type": "Connascency of Meaning (CoM)",
        "description": "The most subtle form of connascency, where modules must agree on the meaning or interpretation of data.",
        "example": "Two modules both assume a status code of '1' means 'success', even if it's not explicitly defined anywhere.",
        "translation": "关联性的最微妙形式，模块必须对数据的含义或解释达成一致。例如：两个模块都假设状态码'1'表示'成功'，即使它在任何地方都没有明确定义。"
      }
    ]
  },
  "phrases": {
    "examples": [
      {
        "phrase": "reduce connascency",
        "translation": "减少关联性"
      },
      {
        "phrase": "high connascency",
        "translation": "高关联性"
      },
      {
        "phrase": "low connascency",
        "translation": "低关联性"
      }
    ],
    "idioms": []
  }
}
```