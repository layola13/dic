```json
{
  "word": "mutex",
  "phonetics": "/ˈmjuːtɛks/",
  "part_of_speech": "noun",
  "translation": "互斥锁",
  "definition": "A programming object that prevents multiple threads from accessing a shared resource simultaneously. It ensures that only one thread can acquire the mutex at a time, thus protecting the critical section of code.",
  "example": "The mutex ensures that only one thread can update the shared counter at any given time, preventing race conditions.",
  "synonyms": ["lock", "semaphore", "critical section"],
  "antonyms": [],
  "usage": {
    "basic_usage": [
      {
        "example": "The thread acquired the mutex before accessing the shared data.",
        "translation": "线程在访问共享数据之前获取了互斥锁。"
      },
      {
        "example": "Releasing the mutex allows other threads to access the protected resource.",
        "translation": "释放互斥锁允许其他线程访问受保护的资源。"
      }
    ],
    "code_examples": [
      {
        "language": "C++",
        "code": "#include <iostream>\n#include <thread>\n#include <mutex>\n\nstd::mutex mtx;\nint counter = 0;\n\nvoid increment_counter() {\n    for (int i = 0; i < 100000; ++i) {\n        mtx.lock();\n        counter++;\n        mtx.unlock();\n    }\n}\n\nint main() {\n    std::thread t1(increment_counter);\n    std::thread t2(increment_counter);\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"Counter value: \" << counter << std::endl;\n    return 0;\n}",
        "explanation": "This C++ code demonstrates how a mutex is used to protect a shared counter from race conditions. The `mtx.lock()` and `mtx.unlock()` calls ensure that only one thread can increment the counter at a time.",
        "translation": "这段C++代码演示了如何使用互斥锁来保护共享计数器免受竞争条件的影响。`mtx.lock()` 和 `mtx.unlock()` 调用确保一次只有一个线程可以增加计数器。"
      },
      {
        "language": "Python",
        "code": "import threading\n\nmutex = threading.Lock()\ncounter = 0\n\ndef increment_counter():\n    global counter\n    for _ in range(100000):\n        with mutex:\n            counter += 1\n\nthread1 = threading.Thread(target=increment_counter)\nthread2 = threading.Thread(target=increment_counter)\n\nthread1.start()\nthread2.start()\n\nthread1.join()\nthread2.join()\n\nprint(\"Counter value:\", counter)",
        "explanation": "This Python code uses a `threading.Lock` object as a mutex to protect the shared `counter` variable. The `with mutex:` statement ensures that the mutex is automatically acquired and released, even if exceptions occur.",
        "translation": "这段Python代码使用 `threading.Lock` 对象作为互斥锁来保护共享的 `counter` 变量。`with mutex:` 语句确保互斥锁被自动获取和释放，即使发生异常。"
      }
    ],
    "common_operations": [
      {
        "operation": "Acquire (Lock)",
        "description": "A thread attempts to acquire the mutex. If the mutex is already held by another thread, the calling thread will block until the mutex becomes available.",
        "translation": "线程尝试获取互斥锁。如果互斥锁已经被另一个线程持有，则调用线程将阻塞，直到互斥锁可用。"
      },
      {
        "operation": "Release (Unlock)",
        "description": "The thread that holds the mutex releases it, allowing another waiting thread to acquire it.",
        "translation": "持有互斥锁的线程释放它，允许另一个等待线程获取它。"
      }
    ],
    "potential_issues": [
      {
        "issue": "Deadlock",
        "description": "A situation where two or more threads are blocked forever, waiting for each other to release the mutexes that they need.",
        "translation": "一种情况，其中两个或多个线程永远阻塞，等待彼此释放它们需要的互斥锁。"
      },
      {
        "issue": "Priority Inversion",
        "description": "A lower-priority thread holds a mutex that a higher-priority thread needs, causing the higher-priority thread to be blocked.",
        "translation": "低优先级线程持有高优先级线程需要的互斥锁，导致高优先级线程被阻塞。"
      }
    ]
  },
  "phrases": {
    "examples": [
      {
        "phrase": "Mutex lock",
        "translation": "互斥锁"
      },
      {
        "phrase": "Acquire mutex",
        "translation": "获取互斥锁"
      },
      {
        "phrase": "Release mutex",
        "translation": "释放互斥锁"
      }
    ],
    "idioms": []
  }
}
``` 