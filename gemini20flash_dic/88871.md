```json
{
  "word": "hoisting",
  "phonetics": "/ˈhɔɪstɪŋ/",
  "part_of_speech": "noun (in programming)",
  "translation": "提升",
  "definition": "In JavaScript, hoisting is a behavior where variable and function declarations are moved to the top of their scope before code execution. This means you can use a variable or function before it's actually declared in the code.",
  "example": "Due to hoisting, you can call a function declared later in your JavaScript code without causing an error.",
  "synonyms": [],
  "antonyms": [],
  "usage": {
    "variable_hoisting": [
      {
        "example": "console.log(myVar); var myVar = 10; // Outputs: undefined",
        "translation": "由于变量提升，`myVar` 在声明之前被使用，但其值为 `undefined`。"
      },
      {
        "example": "let myLet; console.log(myLet); myLet = 20; // Outputs: undefined",
        "translation": "使用 `let` 声明的变量也会提升，但在声明之前访问会抛出错误。"
      },
      {
        "example": "const myConst = 30; console.log(myConst); // Outputs: 30",
        "translation": "使用 `const` 声明的常量也会提升，但在声明之前访问会抛出错误。"
      }
    ],
    "function_hoisting": [
      {
        "example": "myFunction(); function myFunction() { console.log('Function is called'); } // Outputs: Function is called",
        "translation": "函数声明会被提升到作用域的顶部，因此可以在声明之前调用。"
      },
      {
        "example": "var myFunctionExpression = function() { console.log('Function expression'); }; myFunctionExpression(); // Outputs: Function expression",
        "translation": "函数表达式不会被提升，因此在声明之前调用会抛出错误。"
      }
    ],
    "scope": [
      {
        "example": "function example() { console.log(myVar); var myVar = 5; } example(); // Outputs: undefined",
        "translation": "变量提升发生在函数作用域内，变量在函数内部声明之前被使用，但值为 `undefined`。"
      },
      {
        "example": "if (true) { var myVar = 10; } console.log(myVar); // Outputs: 10",
        "translation": "使用 `var` 声明的变量会提升到最近的函数作用域或全局作用域。"
      }
    ],
    "temporal_dead_zone": [
      {
        "example": "console.log(myLet); let myLet = 20; // Throws: ReferenceError: Cannot access 'myLet' before initialization",
        "translation": "`let` 和 `const` 声明的变量存在暂时性死区，即在声明之前访问会抛出错误。"
      },
      {
        "example": "console.log(myConst); const myConst = 30; // Throws: ReferenceError: Cannot access 'myConst' before initialization",
        "translation": "在暂时性死区内访问变量会导致引用错误。"
      }
    ]
  },
  "phrases": {
    "examples": [],
    "idioms": []
  }
}
```
 