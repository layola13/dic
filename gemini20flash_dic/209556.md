```json
{
  "word": "subclassed",
  "phonetics": "/ˌsʌbˈklæst/",
  "part_of_speech": "verb (past tense and past participle)",
  "translation": "子类化；继承（已子类化）",
  "definition": "Having created a new class based on an existing class, inheriting its properties and methods and potentially adding or modifying them.",
  "example": "The button control was subclassed to add a custom hover effect.",
  "synonyms": ["inherited", "derived"],
  "antonyms": ["superclassed"],
  "usage": {
    "simple_past": [
      {
        "sentence": "The developer subclassed the `UIView` to create a custom button.",
        "translation": "开发人员对`UIView`进行了子类化，以创建一个自定义按钮。"
      },
      {
        "sentence": "We subclassed the animal class to create the dog and cat classes.",
        "translation": "我们对动物类进行了子类化，以创建狗和猫类。"
      }
    ],
    "past_perfect": [
      {
        "sentence": "By the time the new feature was implemented, the class had already been subclassed by several other teams.",
        "translation": "在新功能实施时，该类已经被其他几个团队子类化。"
      },
      {
        "sentence": "He realized that he had subclassed the wrong class, leading to unexpected behavior.",
        "translation": "他意识到他子类化了错误的类，导致了意想不到的行为。"
      }
    ],
    "passive_voice": [
      {
        "sentence": "The base class was subclassed to add specific functionality.",
        "translation": "该基类被子类化以添加特定功能。"
      },
      {
        "sentence": "The widget was subclassed in order to customize its appearance.",
        "translation": "该小部件被子类化，以便自定义其外观。"
      }
    ],
    "present_perfect": [
      {
        "sentence": "They have subclassed the component to implement a specific business requirement.",
        "translation": "他们已经对该组件进行了子类化，以实现特定的业务需求。"
      },
      {
        "sentence": "The class has been subclassed multiple times to extend its features.",
        "translation": "该类已被多次子类化以扩展其功能。"
      }
    ],
    "gerund": [
      {
        "sentence": "Subclassing the original class allowed for modular code and easier maintenance.",
        "translation": "子类化原始类可以实现模块化代码和更轻松的维护。"
      },
      {
        "sentence": "Avoid subclassing if composition can achieve the same result.",
        "translation": "如果组合可以实现相同的结果，则避免子类化。"
      }
    ]
  },
  "phrases": {
    "examples": [],
    "idioms": []
  }
}
```