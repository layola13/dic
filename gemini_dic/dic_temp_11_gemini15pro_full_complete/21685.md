bne:/biː ɛn iː/ | abbreviation | branch not equal |  A conditional instruction in assembly language that branches to a specified location if the zero flag is not set, indicating that the previous comparison or operation did not result in zero. | Example: `bne loop` (if the result of the previous operation is not zero, jump to the label "loop"). | 近义词: jnz (jump not zero) | 反义词: beq (branch if equal), jz (jump if zero) | abbreviation


USAGE->

一般现在时 (Simple Present):
The BNE instruction checks the zero flag.  BNE指令检查零标志。

The program executes the next instruction if the zero flag is set. 如果零标志被设置，程序执行下一条指令。


现在进行时 (Present Continuous):
The CPU is evaluating the zero flag before executing the BNE instruction.  CPU正在执行BNE指令之前评估零标志。

The program is branching to a different location because the zero flag is not set. 程序正在分支到不同的位置，因为零标志未设置。


现在完成时 (Present Perfect):
The BNE instruction has branched to the specified label several times during the program's execution.  在程序执行期间，BNE指令已经多次分支到指定的标签。

The program has avoided an error because the BNE instruction detected a non-zero value.  由于BNE指令检测到非零值，程序避免了错误。


现在完成进行时 (Present Perfect Continuous):
The program has been using BNE instructions to control the flow of execution for the past hour.  在过去的一个小时里，程序一直在使用BNE指令来控制执行流程。

The CPU has been checking the zero flag repeatedly before executing each BNE instruction. CPU一直在重复检查零标志，然后再执行每个BNE指令。


一般过去时 (Simple Past):
The BNE instruction branched to the error handling routine. BNE指令分支到错误处理例程。

The program terminated because the BNE instruction detected an unexpected value. 程序终止，因为BNE指令检测到意外值。


过去进行时 (Past Continuous):
The program was executing the loop when the BNE instruction was encountered.  当遇到BNE指令时，程序正在执行循环。

The CPU was evaluating a complex expression when the BNE instruction checked the zero flag. 当BNE指令检查零标志时，CPU正在评估一个复杂的表达式。


过去完成时 (Past Perfect):
The program had already processed several data items before the BNE instruction branched to a different part of the code.  在BNE指令分支到代码的不同部分之前，程序已经处理了几个数据项。

The BNE instruction had prevented a critical error before the program completed.  在程序完成之前，BNE指令防止了严重错误。


过去完成进行时 (Past Perfect Continuous):
The program had been running smoothly for hours before the BNE instruction detected an anomaly.  在BNE指令检测到异常之前，程序已经平稳运行了几个小时。

The CPU had been processing data efficiently before encountering the BNE instruction that changed the program's flow.  在遇到改变程序流程的BNE指令之前，CPU一直在高效地处理数据。


一般将来时 (Simple Future):
The BNE instruction will determine the next step in the program's execution.  BNE指令将决定程序执行的下一步。

The program will loop until the BNE instruction detects a specific condition.  程序将循环，直到BNE指令检测到特定条件。


将来进行时 (Future Continuous):
The CPU will be evaluating the zero flag when it encounters the BNE instruction.  当CPU遇到BNE指令时，它将评估零标志。

The program will be branching to a different section of code if the BNE condition is met. 如果满足BNE条件，程序将分支到不同的代码段。


将来完成时 (Future Perfect):
By the time the program reaches the end, the BNE instruction will have controlled the flow of execution numerous times.  当程序到达结尾时，BNE指令将已经多次控制了执行流程。

The program will have successfully completed its task if the BNE instructions function correctly.  如果BNE指令功能正常，程序将成功完成其任务。


将来完成进行时 (Future Perfect Continuous):
The program will have been relying on BNE instructions to handle conditional logic for the entire duration of its execution.  在整个执行过程中，程序将一直依赖BNE指令来处理条件逻辑。

The CPU will have been checking the zero flag countless times by the time the program finishes.  当程序完成时，CPU将已经检查了无数次的零标志。


PHRASE->
BNE loop  BNE循环
BNE error_handler  BNE错误处理程序
BNE next_instruction BNE下一条指令
BNE exit BNE退出
BNE subroutine BNE子程序
