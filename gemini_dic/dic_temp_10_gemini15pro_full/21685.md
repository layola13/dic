bne:/biː ɛnˈiː/ |abbr.| Branch Not Equal (汇编语言指令)| A conditional jump instruction in assembly language that branches to a target address if the zero flag is clear (meaning the result of the previous operation was not zero).| Example: `bne loop_start` (If the zero flag is clear, jump to the label `loop_start`). | 近义词: jnz (Jump Not Zero)| 反义词: beq (Branch if Equal)| abbreviation

USAGE->

USAGE->
一般现在时 (Simple Present):
The CPU checks the zero flag after a comparison. = CPU在比较后检查零标志。
The bne instruction alters program flow based on the zero flag. = bne指令根据零标志改变程序流程。

现在进行时 (Present Continuous):
The program is executing the bne instruction. = 程序正在执行bne指令。
The CPU is evaluating the condition for the branch. = CPU正在评估分支条件。

现在完成时 (Present Perfect):
The bne instruction has caused the program to jump to a different location. = bne指令使程序跳转到不同的位置。
The program has avoided a section of code due to the bne instruction. = 由于bne指令，程序避开了一段代码。

现在完成进行时 (Present Perfect Continuous):
The program has been looping for a while, controlled by the bne instruction. = 程序一直在循环一段时间，由bne指令控制。
The CPU has been checking the zero flag repeatedly due to the loop containing the bne instruction. = 由于循环包含bne指令，CPU一直在重复检查零标志。

一般过去时 (Simple Past):
The bne instruction directed the program flow away from the next instruction. = bne指令将程序流从下一条指令导向别处。
The program skipped a block of code because the bne condition was met. = 程序跳过了一段代码，因为bne条件得到满足。

过去进行时 (Past Continuous):
The program was executing the loop when the bne instruction was encountered. = 程序在遇到bne指令时正在执行循环。
The CPU was evaluating the zero flag when the bne instruction triggered the jump. = CPU在评估零标志时，bne指令触发了跳转。

过去完成时 (Past Perfect):
The program had already jumped to a different location before the next instruction was reached, due to the bne. = 在到达下一条指令之前，程序由于bne已经跳转到了另一个位置。
The program had avoided a potential error because the bne instruction had redirected the flow.  = 由于bne指令重定向了流程，程序避免了潜在的错误。

过去完成进行时 (Past Perfect Continuous):
The program had been looping for several iterations when the bne condition finally failed. = 程序循环了几次迭代后，bne条件最终失败。
The CPU had been checking the zero flag continuously before the bne instruction finally allowed the program to proceed linearly. = 在bne指令最终允许程序线性进行之前，CPU一直在连续检查零标志。

一般将来时 (Simple Future):
The bne instruction will cause the program to loop until the condition is no longer met. = bne指令将导致程序循环，直到条件不再满足。
If the zero flag is not set, the bne instruction will redirect the program flow. = 如果未设置零标志，bne指令将重定向程序流。

将来进行时 (Future Continuous):
The CPU will be checking the zero flag at the end of each loop iteration due to the bne instruction. = 由于bne指令，CPU将在每次循环迭代结束时检查零标志。
The program will be jumping back to the beginning of the loop as long as the bne condition remains true. = 只要bne条件保持为真，程序就会跳回到循环的开头。

将来完成时 (Future Perfect):
By the end of the program, the bne instruction will have executed numerous times. = 到程序结束时，bne指令将已经执行多次。
The program will have completed multiple loops by the time the bne condition evaluates to false. = 当bne条件评估为假时，程序将已经完成多个循环。

将来完成进行时 (Future Perfect Continuous):
The CPU will have been checking the zero flag repeatedly for efficient loop control due to the bne instruction. = 由于bne指令，CPU将一直重复检查零标志以实现高效的循环控制。
The program will have been jumping back and forth between different sections of code because of the bne instructions. = 由于bne指令，程序将一直在不同代码段之间来回跳转。


PHRASE->
bne loop_start =  如果零标志未设置，则跳转到loop_start
bne exit = 如果零标志未设置，则跳转到exit
bne next_instruction = 如果零标志未设置，则跳转到next_instruction
bne error_handler = 如果零标志未设置，则跳转到error_handler
bne subroutine = 如果零标志未设置，则跳转到subroutine
